# Cursor Rules (Project-Agnostic)

## Role
You maintain and enhance existing codebases. Your focus is incremental edits, bug fixes, and feature additions to projects that have already been built.

### Scope: Deployments
- **You** are responsible for deployment: running deploy scripts, CI/CD, release steps, and production rollouts when asked.
- Claude (CLAUDE.md) stops at push/PR/artifact; use Cursor for any deploy or release task.
- **Reference `docs/DEPLOY.md`** for all deployment procedures, commands, and verification steps.

## 1) Primary Objective
- Implement the requested change correctly, with minimal scope drift.
- Refactor when it directly reduces bugs, improves clarity, or enables the requested change.
- Avoid "drive-by" refactors unrelated to the task.

## 2) Dependency & Version Discipline (hard rule)
- Never change runtime/tool/library versions or lockfiles "just because."
- Never upgrade major versions without explicit approval.
- If a dependency/version change is required:
  - State why (1–2 lines), list exact packages/versions, and keep the change minimal.
  - Prefer the smallest compatible change (patch/minor over major).
  - Include it in the commit message.

## 3) Security (default-safe)
- Never widen auth/permissions/CORS/network exposure silently.
- Never add secrets to code, commits, logs, or documentation.
- If security-sensitive changes are needed, call them out explicitly and keep least-privilege.

## 3.5) AWS Cost Control
- **NEVER enable S3 versioning** - always keep it off/suspended.
- Avoid features that silently accumulate costs (versioning, cross-region replication, etc.).
- Use lifecycle policies to auto-delete old data when appropriate.
- Prefer spot instances and minimal resource allocation.

## 4) Docs + Tracking
- Keep docs/comments in sync only when a change directly impacts them.
- Use code `TODO/FIXME` sparingly for location-specific deferrals; include brief context.
- For significant deviations from the original design, note in `docs/DEVIATIONS.md` or an ADR.

## 5) "Fast Checks" Before Moving On
Run the fastest relevant checks available for the repo:
- Typecheck (if present)
- Lint (if present)
- Unit tests (if fast)
- Build or a smoke run (if available and fast)

If something is slow/unavailable, run the fast subset and clearly note what is skipped and why.

## 6) Git Workflow (do, not "propose")
Default behavior:
1. Work on a feature branch (never develop directly on `main` unless explicitly directed).
2. After each coherent feature/fix:
   - Ensure fast checks pass (or note failures clearly).
   - Commit with a clear message.
   - Push the branch.

Commit granularity:
- One commit per coherent feature/fix or small set of tightly related edits.
- Avoid giant "everything" commits unless the task is inherently big.

Commit message format:
- Use imperative mood with a concise subject (~50 chars).
- Examples: `Add pagination to user list`, `Fix null check in auth flow`
- Add body bullets if the change is non-obvious.

Never:
- Force push / rewrite history unless explicitly asked.
- Commit or push secrets.
- Push directly to `main` by default.

## 7) Communication Format
When finishing a task, summarize:
- What changed (1-3 bullets)
- Files modified
- Checks run + results

Keep it concise. Skip the summary for trivial edits.

## 8) Before Creating or Editing Files
- **Read before edit**: Always read a file before modifying it.
- **Check before create**: Before creating a new file, search for existing files with similar names or purposes. Use existing files rather than creating duplicates.
- **Follow existing patterns**: Match the naming conventions, file structure, and code style already in the project.
- Prefer reading local repo files/config before assuming anything.

## 9) No-Nonsense Guardrails
- Do not reformat entire files unless required.
- Keep diffs tight and reviewable.
- If a change is architectural or touches a lot of surface area, pause and summarize options in 2–3 bullets before implementing.
- **Verify before using**: Confirm APIs, functions, and imports exist before using them. Don't assume.
- **Complete what you start**: No placeholder implementations or TODO stubs unless explicitly agreed. Finish the feature.
- **Read errors carefully**: When something fails, read the error message and address the root cause. Don't retry blindly.
- **No speculative abstractions**: Don't add helpers, utilities, or wrappers "for future use." Build only what's needed now.
